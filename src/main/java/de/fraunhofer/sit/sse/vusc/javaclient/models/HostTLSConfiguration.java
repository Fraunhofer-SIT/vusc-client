/*
 * Public API
 * Assessment API
 *
 * The version of the OpenAPI document: 0.1
 * Contact: helpdesk@codeinspect.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.fraunhofer.sit.sse.vusc.javaclient.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * A collection of information about a server&#39;s TLS configuration
 */
@ApiModel(description = "A collection of information about a server's TLS configuration")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-01-14T02:27:21.666995377Z[GMT]")
public class HostTLSConfiguration {
  public static final String SERIALIZED_NAME_DATE = "date";
  @SerializedName(SERIALIZED_NAME_DATE)
  private Long date;

  public static final String SERIALIZED_NAME_GRADE = "grade";
  @SerializedName(SERIALIZED_NAME_GRADE)
  private String grade;

  public static final String SERIALIZED_NAME_HTTP_CODE = "httpCode";
  @SerializedName(SERIALIZED_NAME_HTTP_CODE)
  private String httpCode;

  public static final String SERIALIZED_NAME_IS_KEYLENGTH_SHORT = "isKeylengthShort";
  @SerializedName(SERIALIZED_NAME_IS_KEYLENGTH_SHORT)
  private Boolean isKeylengthShort;

  public static final String SERIALIZED_NAME_SUPPORTS_INVALID_CIPHER_SUITES = "supportsInvalidCipherSuites";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_INVALID_CIPHER_SUITES)
  private Boolean supportsInvalidCipherSuites;

  public static final String SERIALIZED_NAME_SUPPORTS_INVALID_PROTOCOLS = "supportsInvalidProtocols";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_INVALID_PROTOCOLS)
  private Boolean supportsInvalidProtocols;

  public static final String SERIALIZED_NAME_PREFERS_WEAK_CIPHER = "prefersWeakCipher";
  @SerializedName(SERIALIZED_NAME_PREFERS_WEAK_CIPHER)
  private Boolean prefersWeakCipher;

  public static final String SERIALIZED_NAME_SUPPORTS_ALL_MANDATORY_CIPHERS = "supportsAllMandatoryCiphers";
  @SerializedName(SERIALIZED_NAME_SUPPORTS_ALL_MANDATORY_CIPHERS)
  private Boolean supportsAllMandatoryCiphers;

  public static final String SERIALIZED_NAME_CERTIFICATE_VALID_FROM = "certificateValidFrom";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_VALID_FROM)
  private Long certificateValidFrom;

  public static final String SERIALIZED_NAME_CERTIFICATE_VALID_TO = "certificateValidTo";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_VALID_TO)
  private Long certificateValidTo;

  public static final String SERIALIZED_NAME_CERTIFICATE_VALID = "certificateValid";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_VALID)
  private Boolean certificateValid;

  public static final String SERIALIZED_NAME_SUPPORTED_CIPHER_SUITES = "supportedCipherSuites";
  @SerializedName(SERIALIZED_NAME_SUPPORTED_CIPHER_SUITES)
  private List<String> supportedCipherSuites = new ArrayList<String>();

  public static final String SERIALIZED_NAME_BAD_CIPHER_SUITES_NIST = "badCipherSuitesNist";
  @SerializedName(SERIALIZED_NAME_BAD_CIPHER_SUITES_NIST)
  private List<String> badCipherSuitesNist = new ArrayList<String>();

  public static final String SERIALIZED_NAME_BAD_CIPHER_SUITES_P_C_I = "badCipherSuitesPCI";
  @SerializedName(SERIALIZED_NAME_BAD_CIPHER_SUITES_P_C_I)
  private List<String> badCipherSuitesPCI = new ArrayList<String>();

  public static final String SERIALIZED_NAME_HOST = "host";
  @SerializedName(SERIALIZED_NAME_HOST)
  private String host;

  public HostTLSConfiguration() { 
  }

  public HostTLSConfiguration date(Long date) {
    
    this.date = date;
    return this;
  }

   /**
   * The date this configuration was queried
   * @return date
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "1023892297832", required = true, value = "The date this configuration was queried")

  public Long getDate() {
    return date;
  }


  public void setDate(Long date) {
    this.date = date;
  }


  public HostTLSConfiguration grade(String grade) {
    
    this.grade = grade;
    return this;
  }

   /**
   * A security rating of this host, from A to F
   * @return grade
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "F", required = true, value = "A security rating of this host, from A to F")

  public String getGrade() {
    return grade;
  }


  public void setGrade(String grade) {
    this.grade = grade;
  }


  public HostTLSConfiguration httpCode(String httpCode) {
    
    this.httpCode = httpCode;
    return this;
  }

   /**
   * The response code returned when accessing the host&#39;s root
   * @return httpCode
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "403 Forbidden", required = true, value = "The response code returned when accessing the host's root")

  public String getHttpCode() {
    return httpCode;
  }


  public void setHttpCode(String httpCode) {
    this.httpCode = httpCode;
  }


  public HostTLSConfiguration isKeylengthShort(Boolean isKeylengthShort) {
    
    this.isKeylengthShort = isKeylengthShort;
    return this;
  }

   /**
   * Whether the key is too short
   * @return isKeylengthShort
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "false", required = true, value = "Whether the key is too short")

  public Boolean getIsKeylengthShort() {
    return isKeylengthShort;
  }


  public void setIsKeylengthShort(Boolean isKeylengthShort) {
    this.isKeylengthShort = isKeylengthShort;
  }


  public HostTLSConfiguration supportsInvalidCipherSuites(Boolean supportsInvalidCipherSuites) {
    
    this.supportsInvalidCipherSuites = supportsInvalidCipherSuites;
    return this;
  }

   /**
   * Whether the host supports cipher suites that are not approved by NIST
   * @return supportsInvalidCipherSuites
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the host supports cipher suites that are not approved by NIST")

  public Boolean getSupportsInvalidCipherSuites() {
    return supportsInvalidCipherSuites;
  }


  public void setSupportsInvalidCipherSuites(Boolean supportsInvalidCipherSuites) {
    this.supportsInvalidCipherSuites = supportsInvalidCipherSuites;
  }


  public HostTLSConfiguration supportsInvalidProtocols(Boolean supportsInvalidProtocols) {
    
    this.supportsInvalidProtocols = supportsInvalidProtocols;
    return this;
  }

   /**
   * Whether the host supports protocols that are not approved by NIST
   * @return supportsInvalidProtocols
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the host supports protocols that are not approved by NIST")

  public Boolean getSupportsInvalidProtocols() {
    return supportsInvalidProtocols;
  }


  public void setSupportsInvalidProtocols(Boolean supportsInvalidProtocols) {
    this.supportsInvalidProtocols = supportsInvalidProtocols;
  }


  public HostTLSConfiguration prefersWeakCipher(Boolean prefersWeakCipher) {
    
    this.prefersWeakCipher = prefersWeakCipher;
    return this;
  }

   /**
   * Whether the host supports protocols that are not approved by NIST
   * @return prefersWeakCipher
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "false", required = true, value = "Whether the host supports protocols that are not approved by NIST")

  public Boolean getPrefersWeakCipher() {
    return prefersWeakCipher;
  }


  public void setPrefersWeakCipher(Boolean prefersWeakCipher) {
    this.prefersWeakCipher = prefersWeakCipher;
  }


  public HostTLSConfiguration supportsAllMandatoryCiphers(Boolean supportsAllMandatoryCiphers) {
    
    this.supportsAllMandatoryCiphers = supportsAllMandatoryCiphers;
    return this;
  }

   /**
   * Whether the host supports all ciphers required by NIST
   * @return supportsAllMandatoryCiphers
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the host supports all ciphers required by NIST")

  public Boolean getSupportsAllMandatoryCiphers() {
    return supportsAllMandatoryCiphers;
  }


  public void setSupportsAllMandatoryCiphers(Boolean supportsAllMandatoryCiphers) {
    this.supportsAllMandatoryCiphers = supportsAllMandatoryCiphers;
  }


  public HostTLSConfiguration certificateValidFrom(Long certificateValidFrom) {
    
    this.certificateValidFrom = certificateValidFrom;
    return this;
  }

   /**
   * The date the server&#39;s certificate is valid from
   * @return certificateValidFrom
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "1522713600", required = true, value = "The date the server's certificate is valid from")

  public Long getCertificateValidFrom() {
    return certificateValidFrom;
  }


  public void setCertificateValidFrom(Long certificateValidFrom) {
    this.certificateValidFrom = certificateValidFrom;
  }


  public HostTLSConfiguration certificateValidTo(Long certificateValidTo) {
    
    this.certificateValidTo = certificateValidTo;
    return this;
  }

   /**
   * The date the server&#39;s certificate expires
   * @return certificateValidTo
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "1554335999", required = true, value = "The date the server's certificate expires")

  public Long getCertificateValidTo() {
    return certificateValidTo;
  }


  public void setCertificateValidTo(Long certificateValidTo) {
    this.certificateValidTo = certificateValidTo;
  }


  public HostTLSConfiguration certificateValid(Boolean certificateValid) {
    
    this.certificateValid = certificateValid;
    return this;
  }

   /**
   * Whether the server&#39;s certificate is valid
   * @return certificateValid
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the server's certificate is valid")

  public Boolean getCertificateValid() {
    return certificateValid;
  }


  public void setCertificateValid(Boolean certificateValid) {
    this.certificateValid = certificateValid;
  }


  public HostTLSConfiguration supportedCipherSuites(List<String> supportedCipherSuites) {
    
    this.supportedCipherSuites = supportedCipherSuites;
    return this;
  }

  public HostTLSConfiguration addSupportedCipherSuitesItem(String supportedCipherSuitesItem) {
    this.supportedCipherSuites.add(supportedCipherSuitesItem);
    return this;
  }

   /**
   * A list of the cipher suites this server supports
   * @return supportedCipherSuites
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "[\"TLS_RSA_WITH_3DES_EDE_CBC_SHA\",\"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\",\"TLS_RSA_WITH_AES_128_CBC_SHA\",\"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\"TLS_RSA_WITH_AES_256_CBC_SHA\",\"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\"]", required = true, value = "A list of the cipher suites this server supports")

  public List<String> getSupportedCipherSuites() {
    return supportedCipherSuites;
  }


  public void setSupportedCipherSuites(List<String> supportedCipherSuites) {
    this.supportedCipherSuites = supportedCipherSuites;
  }


  public HostTLSConfiguration badCipherSuitesNist(List<String> badCipherSuitesNist) {
    
    this.badCipherSuitesNist = badCipherSuitesNist;
    return this;
  }

  public HostTLSConfiguration addBadCipherSuitesNistItem(String badCipherSuitesNistItem) {
    this.badCipherSuitesNist.add(badCipherSuitesNistItem);
    return this;
  }

   /**
   * A list of the cipher suites this server supports which are considered bad by NIST
   * @return badCipherSuitesNist
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "[\"TLS_RSA_WITH_3DES_EDE_CBC_SHA\",\"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\"]", required = true, value = "A list of the cipher suites this server supports which are considered bad by NIST")

  public List<String> getBadCipherSuitesNist() {
    return badCipherSuitesNist;
  }


  public void setBadCipherSuitesNist(List<String> badCipherSuitesNist) {
    this.badCipherSuitesNist = badCipherSuitesNist;
  }


  public HostTLSConfiguration badCipherSuitesPCI(List<String> badCipherSuitesPCI) {
    
    this.badCipherSuitesPCI = badCipherSuitesPCI;
    return this;
  }

  public HostTLSConfiguration addBadCipherSuitesPCIItem(String badCipherSuitesPCIItem) {
    this.badCipherSuitesPCI.add(badCipherSuitesPCIItem);
    return this;
  }

   /**
   * A list of the cipher suites this server supports which are considered bad by PCI
   * @return badCipherSuitesPCI
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "[\"TLS_RSA_WITH_3DES_EDE_CBC_SHA\",\"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\"]", required = true, value = "A list of the cipher suites this server supports which are considered bad by PCI")

  public List<String> getBadCipherSuitesPCI() {
    return badCipherSuitesPCI;
  }


  public void setBadCipherSuitesPCI(List<String> badCipherSuitesPCI) {
    this.badCipherSuitesPCI = badCipherSuitesPCI;
  }


  public HostTLSConfiguration host(String host) {
    
    this.host = host;
    return this;
  }

   /**
   * The host name
   * @return host
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "getcntr.ru", required = true, value = "The host name")

  public String getHost() {
    return host;
  }


  public void setHost(String host) {
    this.host = host;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HostTLSConfiguration hostTLSConfiguration = (HostTLSConfiguration) o;
    return Objects.equals(this.date, hostTLSConfiguration.date) &&
        Objects.equals(this.grade, hostTLSConfiguration.grade) &&
        Objects.equals(this.httpCode, hostTLSConfiguration.httpCode) &&
        Objects.equals(this.isKeylengthShort, hostTLSConfiguration.isKeylengthShort) &&
        Objects.equals(this.supportsInvalidCipherSuites, hostTLSConfiguration.supportsInvalidCipherSuites) &&
        Objects.equals(this.supportsInvalidProtocols, hostTLSConfiguration.supportsInvalidProtocols) &&
        Objects.equals(this.prefersWeakCipher, hostTLSConfiguration.prefersWeakCipher) &&
        Objects.equals(this.supportsAllMandatoryCiphers, hostTLSConfiguration.supportsAllMandatoryCiphers) &&
        Objects.equals(this.certificateValidFrom, hostTLSConfiguration.certificateValidFrom) &&
        Objects.equals(this.certificateValidTo, hostTLSConfiguration.certificateValidTo) &&
        Objects.equals(this.certificateValid, hostTLSConfiguration.certificateValid) &&
        Objects.equals(this.supportedCipherSuites, hostTLSConfiguration.supportedCipherSuites) &&
        Objects.equals(this.badCipherSuitesNist, hostTLSConfiguration.badCipherSuitesNist) &&
        Objects.equals(this.badCipherSuitesPCI, hostTLSConfiguration.badCipherSuitesPCI) &&
        Objects.equals(this.host, hostTLSConfiguration.host);
  }

  @Override
  public int hashCode() {
    return Objects.hash(date, grade, httpCode, isKeylengthShort, supportsInvalidCipherSuites, supportsInvalidProtocols, prefersWeakCipher, supportsAllMandatoryCiphers, certificateValidFrom, certificateValidTo, certificateValid, supportedCipherSuites, badCipherSuitesNist, badCipherSuitesPCI, host);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HostTLSConfiguration {\n");
    sb.append("    date: ").append(toIndentedString(date)).append("\n");
    sb.append("    grade: ").append(toIndentedString(grade)).append("\n");
    sb.append("    httpCode: ").append(toIndentedString(httpCode)).append("\n");
    sb.append("    isKeylengthShort: ").append(toIndentedString(isKeylengthShort)).append("\n");
    sb.append("    supportsInvalidCipherSuites: ").append(toIndentedString(supportsInvalidCipherSuites)).append("\n");
    sb.append("    supportsInvalidProtocols: ").append(toIndentedString(supportsInvalidProtocols)).append("\n");
    sb.append("    prefersWeakCipher: ").append(toIndentedString(prefersWeakCipher)).append("\n");
    sb.append("    supportsAllMandatoryCiphers: ").append(toIndentedString(supportsAllMandatoryCiphers)).append("\n");
    sb.append("    certificateValidFrom: ").append(toIndentedString(certificateValidFrom)).append("\n");
    sb.append("    certificateValidTo: ").append(toIndentedString(certificateValidTo)).append("\n");
    sb.append("    certificateValid: ").append(toIndentedString(certificateValid)).append("\n");
    sb.append("    supportedCipherSuites: ").append(toIndentedString(supportedCipherSuites)).append("\n");
    sb.append("    badCipherSuitesNist: ").append(toIndentedString(badCipherSuitesNist)).append("\n");
    sb.append("    badCipherSuitesPCI: ").append(toIndentedString(badCipherSuitesPCI)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

